## 面向对象  

### 定义类  
```
class 类名(object):

    def 方法1(self, 参数列表):
        pass

    def 方法2(self, 参数列表):
        pass
```
方法相对于函数只是多了一个 `self` 参数  
你一定会在想 Python 是如何给 `self` 赋值的，以及为什么你不必给它一个值。一个例子或许 会让这些疑问得到解答。假设你有一个 `MyClass` 的类，这个类下有一个实例 myobject 。当 你调用一个这个对象的方法，如 `myobject.method(arg1, arg2)` 时，Python 将会自动将其转 换成 `MyClass.method(myobject, arg1, arg2)` ——这就是 `self` 的全部特殊之处所在。    

`self`，表示创建的实例本身
### 创建对象  
```
对象变量 = 类名()
```
### 内置方法  

| 序号 | 方法名 | 类型 | 作用 |
|:-- |:--|:--|:--|
| 01 | `__new__` | 方法 | 创建对象时，会被 自动 调用 |
| 02 | `__init__` | 方法 | 对象被初始化时，会被 自动 调用 |
| 03 | `__del__` | 方法 | 对象被从内存中销毁前，会被 自动 调用 |
| 04 | `__str__` | 方法 | 返回对象的描述信息，print 函数输出使用 |

> 可以使用 `dir(obj)` 查看  

#### `__new__` 方法  

使用 类名() 创建对象时，Python 的解释器 首先 会 调用 `__new__` 方法为对象 分配空间  
`__new__` 是一个 由 object 基类提供的 内置的静态方法，主要作用有两个：  
1) 在内存中为对象 分配空间  
2) 返回 对象的引用  
Python 的解释器获得对象的 引用 后，将引用作为 第一个参数，传递给 `__init__` 方法  

重写 `__new__` 方法 一定要 `return super().__new__(cls)`
否则 Python 的解释器 得不到 分配了空间的 对象引用，就不会调用对象的初始化方法  
> 注意：`__new__` 是一个~~静态方法~~ 类方法，在调用时需要 主动传递 `cls` 参数  

```
class MusicPlayer(object):

    def __new__(cls, *args, **kwargs):
        # 如果不返回则无法往后执行 __init__
        return super().__new__(cls)

    def __init__(self):
        print("初始化音乐播放对象")

player = MusicPlayer()

print(player)
```

#### 初始化 `__init__`   
初始化方法 `__init__` 主要做的事就是接受创建对象时传递的参数，创建属性，属性的初始化赋值  
```
class Women:

    def __init__(self, name):

        self.name = name
        self.__age = 18
xiaofang = Women("小芳")
```
### 实例属性的创建  
1. 在类的内部创建  
```
class Women:

    def __init__(self, name):
        # 这就创建属性了
        self.name = name
        # 创建私有属性
        self.__age = 18
xiaofang = Women("小芳")
```
2. 通过对象创建  
```
xiaofang.sex = 0
```
这就创建了属性，坑不坑，不建议这样使用  

#### 限制创建实例属性 `__slots__`  
Python允许在定义class的时候，定义一个特殊的 `__slots__` 变量，来限制该class实例能添加的属性：  
```
class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
```
使用 `__slots__` 要注意， `__slots__` 定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：  
除非在子类中也定义 `__slots__` ，这样，子类实例允许定义的属性就是自身的 `__slots__` 加上父类的 `__slots__` 。



### 私有  
在创建私有属性和私有方法的时候只需要在属性名或方法名前加两个下划线 `__`
```
class Women:

    def __init__(self, name):

        self.name = name
        # 不要问女生的年龄
        self.__age = 18

    def __secret(self):
        print("我的年龄是 %d" % self.__age)


xiaofang = Women("小芳")
# 私有属性，外部不能直接访问
# print(xiaofang.__age)

# 私有方法，外部不能直接调用
# xiaofang.__secret()
```
Python 中，并没有 真正意义 的 私有

在给 属性、方法 命名时，实际是对 名称 做了一些特殊处理，使得外界无法访问到
处理方式：在 名称 前面加上 `_类名 => _类名__名称`
```
# 私有属性，外部不能直接访问到
print(xiaofang._Women__age)

# 私有方法，外部不能直接调用
xiaofang._Women__secret()
```

`_x`: 单前置下划线,私有化属性或方法，`from somemodule import *` 禁止导入,类对象和子类可以访问  
`__xx`：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)，子类不继承，子类不能访问  

### 继承  
python 默认继承 `Object` 类  
```
class 类名(父类名):

    pass
```
#### 调用父类的属性/方法  
如果子类对父类的方法进行了重写覆盖，但是想调用父类中的方法可以通过 `super().父类方法名`
关于 super
1. 在 `Python` 中 `super` 是一个 特殊的类
2. `super()` 就是使用 `super` 类创建出来的对象

调用父类方法的另外一种方式（知道）

在 Python 2.x 时，如果需要调用父类的方法，还可以使用以下方式：
```
父类名.方法(self)
```
#### 多继承  
```
class 子类名(父类名1, 父类名2...)
    pass
```
不推荐，因为多个父类中重复的变量的方法将会变得不可控  

##### Python 中的 MRO —— 方法搜索顺序（知道）

Python 中针对 类 提供了一个 内置属性 `__mro__` 可以查看 方法 搜索顺序
MRO 是 method resolution order，主要用于 在多继承时判断 方法、属性 的调用 路径  
假设 `C` 类继承自 `A` 类和 `B` 类  
```
print(C.__mro__)
输出结果

(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
```
##### MixIn  
MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。

假设  
```
class Dog(Mammal, Runnable, Carnivorous):
    pass
```  
由于多个父类中有相同的方法，会导致某个方法不可控，改成MixIn的方式就是让Dog继承一个主线Mammal,而其他两个父类中要用到的最小部分单独摘出来作为一个类，这个类通常以MixIn结尾  
```
class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
```



### 类对象  
在 Python 中，类 是一个特殊的对象 —— 类对象  
除了封装 实例 的 属性 和 方法外，类对象 还可以拥有自己的 属性 和 方法  

所有的实例共享 类属性和类方法，通过类名进行访问  
#### 类属性  

```
class Tool(object):
    # 定义类属性
    # 使用赋值语句，定义类属性，记录创建工具对象的总数
    count = 0

    def __init__(self, name):
        self.name = name

        # 针对类属性做一个计数+1
        Tool.count += 1


# 创建工具对象
tool1 = Tool("斧头")
tool2 = Tool("榔头")
tool3 = Tool("铁锹")

# 知道使用 Tool 类到底创建了多少个对象?
print("现在创建了 %d 个工具" % Tool.count)
```
在 Python 中 属性的获取 存在一个 向上查找机制，**在对象中查找不到的实例属性会自动向上查找类属性**   
因此，要访问类属性有两种方式：
1. 类名.类属性
2. 对象.类属性 （不推荐）

> 如果使用 对象.类属性 = 值 赋值语句，只会 给对象添加一个属性，而不会影响到 类属性的值

#### 类方法  
```
@classmethod
def 类方法名(cls):
    pass
```
1. 类方法需要用 修饰器 `@classmethod` 来标识，告诉解释器这是一个类方法  
2. 类方法的 第一个参数 应该是 `cls`  
    2.1 由 哪一个类 调用的方法，方法内的 cls 就是 哪一个类的引用  
    2.2 这个参数和 实例方法 的第一个参数是 self 类似  
3. 通过 `类名. 调用` 类方法，调用方法时，不需要传递 `cls` 参数  
4. 在方法内部  
    4.1 可以通过 `cls.` 访问类的属性  
    4.2 也可以通过 `cls.` 调用其他的类方法  

#### 静态方法
```
@staticmethod
def 静态方法名():
    pass
```
静态方法也是用过 `类名.` 调用  
和类方法的不同是：没有办法通过 `cls`来访问 类属性 或者调用 类方法，但是可以通过类名直接调用    
但是，这会在继承的时候显示出来差别，因为类方法的 `cls` 参数是动态的，使用的是调用者的类对象，而静态方法是写死的  
#### 实例方法、静态方法和类方法  
三种方法在内存中**都归属于类**，区别在于调用方式不同。

实例方法：由对象调用；至少一个self参数；执行实例方法时，自动将调用该方法的对象赋值给self；  
类方法：由类调用； 至少一个cls参数；执行类方法时，自动将调用该方法的类赋值给cls；  
静态方法：由类调用；无默认参数；    


相同点：对于所有的方法而言，均属于类，所以 在内存中也只保存一份  
不同点：方法调用者不同、调用方法时自动传入的参数不同。  


### 单例  
```
class MusicPlayer(object):

    # 记录第一个被创建对象的引用
    instance = None
    # 记录是否执行过初始化动作
    init_flag = False

    def __new__(cls, *args, **kwargs):

        # 1. 判断类属性是否是空对象
        if cls.instance is None:
            # 2. 调用父类的方法，为第一个对象分配空间
            cls.instance = super().__new__(cls)

        # 3. 返回类属性保存的对象引用
        return cls.instance

    def __init__(self):
        # 防止每次都初始化
        if not MusicPlayer.init_flag:
            print("初始化音乐播放器")

            MusicPlayer.init_flag = True


# 创建多个对象
player1 = MusicPlayer()
print(player1)

player2 = MusicPlayer()
print(player2)
```
**注意点**  
创建对象的时候每次都会执行 `__new__` 和 `__init__` 方法，所以 `__init__` 方法中的初始化也要进行判断  


### is 与 == 区别：

`is` 用于判断 两个变量 引用对象是否为同一个
`==` 用于判断 引用变量的值 是否相等
```
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> b is a
False
>>> b == a
True
```
### 属性操作 getattr()、setattr()、hasattr() 反射获取  
```
>>> class MyObject(object):
...     def __init__(self):
...         self.x = 9
...     def power(self):
...         return self.x * self.x
...
>>> obj = MyObject()
```
紧接着，可以测试该对象的属性：
```
>>> hasattr(obj, 'x') # 有属性'x'吗？
True
>>> obj.x
9
>>> hasattr(obj, 'y') # 有属性'y'吗？
False
>>> setattr(obj, 'y', 19) # 设置一个属性'y'
>>> hasattr(obj, 'y') # 有属性'y'吗？
True
>>> getattr(obj, 'y') # 获取属性'y'
19
>>> obj.y # 获取属性'y'
19
```
如果试图获取不存在的属性，会抛出AttributeError的错误：
```
>>> getattr(obj, 'z') # 获取属性'z'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'MyObject' object has no attribute 'z'
```
可以传入一个default参数，如果属性不存在，就返回默认值：
```
>>> getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
404
```
> 要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。(性能原因)

### 使用装饰器 decorator  
可以将方法当做属性来使用，也就是类似于定义 `getter/setter` 方法  
```
class Student(object):

    @property # 设置成getter属性
    def score(self):
        return self._score

    @score.setter # 设置成setter属性
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value


>>> s = Student()
>>> s.score = 60 # OK，实际转化为s.set_score(60)
>>> s.score # OK，实际转化为s.get_score()
60
>>> s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
```
三种@property装饰器
```
#coding=utf-8
# ############### 定义 ###############
class Goods:
    """python3中默认继承object类
        以python2、3执行此程序的结果不同，因为只有在python3中才有@xxx.setter  @xxx.deleter
    """
    @property
    def price(self):
        print('@property')

    @price.setter
    def price(self, value):
        print('@price.setter')

    @price.deleter
    def price(self):
        print('@price.deleter')

# ############### 调用 ###############
obj = Goods()
obj.price          # 自动执行 @property 修饰的 price 方法，并获取方法的返回值
obj.price = 123    # 自动执行 @price.setter 修饰的 price 方法，并将  123 赋值给方法的参数
del obj.price      # 自动执行 @price.deleter 修饰的 price 方法
```
#### 类属性方式，创建值为property对象的类属性  

property方法中有个四个参数  

第一个参数是方法名，调用 `对象.属性` 时自动触发执行方法  
第二个参数是方法名，调用 `对象.属性 ＝ XXX` 时自动触发执行方法  
第三个参数是方法名，调用 `del 对象.属性` 时自动触发执行方法  
第四个参数是字符串，调用 `对象.属性.__doc__` ，此参数是该属性的描述信息  
```
#coding=utf-8
class Foo(object):
    def get_bar(self):
        print("getter...")
        return 'laowang'

    def set_bar(self, value):
        """必须两个参数"""
        print("setter...")
        return 'set value' + value

    def del_bar(self):
        print("deleter...")
        return 'laowang'

    BAR = property(get_bar, set_bar, del_bar, "description...")

obj = Foo()

obj.BAR  # 自动调用第一个参数中定义的方法：get_bar
obj.BAR = "alex"  # 自动调用第二个参数中定义的方法：set_bar方法，并将“alex”当作参数传入
desc = Foo.BAR.__doc__  # 自动获取第四个参数中设置的值：description...
print(desc)
del obj.BAR  # 自动调用第三个参数中定义的方法：del_bar方法
```
### 魔术属性  
[参考-定制类](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319098638265527beb24f7840aa97de564ccc7f20f6000)  
#### `__doc__` 获取类的描述信息  
```
class Foo:
    """ 描述类信息，这是用于看片的神奇 """
    def func(self):
        pass

print(Foo.__doc__)
#输出：类的描述信息
```
#### `__module__` 模块信息 `__class__`类信息  

test.py
```
# -*- coding:utf-8 -*-

class Person(object):
    def __init__(self):
        self.name = 'laowang'
```      
main.py
```
from test import Person

obj = Person()
print(obj.__module__)  # 输出 test 即：输出模块
print(obj.__class__)  # 输出 test.Person 即：输出类
```

#### `__init__` 创建的时候触发

初始化方法，通过类创建对象时，自动触发执行  
```
class Person:
    def __init__(self, name):
        self.name = name
        self.age = 18


obj = Person('laowang')  # 自动执行类中的 __init__ 方法
```
#### `__del__` 删除对象的时候触发

当对象在内存中被释放时，自动触发执行。
注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，`__del__` 的调用是由解释器在进行垃圾回收时自动触发执行的。
```
class Foo:
    def __del__(self):
        pass
```
#### `__call__` 对象后面加括号，触发执行。

对象后面加括号，触发执行。
注：`__init__` 方法的执行是由创建对象触发的，即：`对象 = 类名()` ；而对于 `__call__` 方法的执行是由对象后加括号触发的，即：`对象() 或者 类()()`
```
class Foo:
    def __init__(self):
        pass

    def __call__(self, *args, **kwargs):
        print('__call__')


obj = Foo()  # 执行 __init__
obj()  # 执行 __call__
```
#### `__dict__` 类或对象中的所有属性和方法

类或对象中的所有属性  
类的实例属性属于对象；类中的类属性和方法等属于类，即：

```
class Province(object):
    country = 'China'

    def __init__(self, name, count):
        self.name = name
        self.count = count

    def func(self, *args, **kwargs):
        print('func')
# 获取类的属性，即：类属性、方法、
print(Province.__dict__)
# 输出：{'__dict__': <attribute '__dict__' of 'Province' objects>, '__module__': '__main__', 'country': 'China', '__doc__': None, '__weakref__': <attribute '__weakref__' of 'Province' objects>, 'func': <function Province.func at 0x101897950>, '__init__': <function Province.__init__ at 0x1018978c8>}

obj1 = Province('山东', 10000)
print(obj1.__dict__)
# 获取 对象obj1 的属性
# 输出：{'count': 10000, 'name': '山东'}

obj2 = Province('山西', 20000)
print(obj2.__dict__)
# 获取 对象obj1 的属性
# 输出：{'count': 20000, 'name': '山西'}
```
#### `__str__` 类当字符串使用的时候

如果一个类中定义了 `__str__` 方法，那么在打印 对象 时，默认输出该方法的返回值。  
```
class Foo:
    def __str__(self):
        return 'laowang'


obj = Foo()
print(obj)
# 输出：laowang
```
#### `__getitem__、__setitem__、__delitem__` 当字典使用  

用于索引操作，如字典。以上分别表示获取、设置、删除数据
```
# -*- coding:utf-8 -*-

class Foo(object):

    def __getitem__(self, key):
        print('__getitem__', key)

    def __setitem__(self, key, value):
        print('__setitem__', key, value)

    def __delitem__(self, key):
        print('__delitem__', key)


obj = Foo()

result = obj['k1']      # 自动触发执行 __getitem__
obj['k2'] = 'laowang'   # 自动触发执行 __setitem__
del obj['k1']           # 自动触发执行 __delitem__
```
#### `__getslice__、__setslice__、__delslice__` 对象切片  

该三个方法用于分片操作，如：列表  
```
# -*- coding:utf-8 -*-

class Foo(object):

    def __getslice__(self, i, j):
        print('__getslice__', i, j)

    def __setslice__(self, i, j, sequence):
        print('__setslice__', i, j)

    def __delslice__(self, i, j):
        print('__delslice__', i, j)

obj = Foo()

obj[-1:1]                   # 自动触发执行 __getslice__
obj[0:1] = [11,22,33,44]    # 自动触发执行 __setslice__
del obj[0:2]                # 自动触发执行 __delslice__
```
#### `__iter__` 和 `__next__` 实现迭代器，用来遍历  
如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个 `__iter__()` 方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的 `__next__()` 方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。

我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：
```
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a > 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
现在，试试把Fib实例作用于for循环：

>>> for n in Fib():
...     print(n)
...
1
1
2
3
5
...
46368
75025
```
#### `__getattr__` `__setattr__` 属性不存在的时候调用  
当属性不存在的时候就会调用 `__getattr__`   
```
class Student(object):

    def __init__(self):
        self.name = 'Michael'

    def __getattr__(self, attr):
        if attr=='score':
            return 99
    def __setattr__(self, key, value):
        self[key] = value
```
当调用不存在的属性时，比如score，Python解释器会试图调用 `__getattr__(self, 'score')` 来尝试获得属性，这样，我们就有机会返回score的值：
```
>>> s = Student()
>>> s.name
'Michael'
>>> s.score
99
```
返回函数也是完全可以的：
```
class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
```
只是调用方式要变为：
```
>>> s = Student()
>>> s.age
<function Student.__getattr__.<locals>.<lambda> at 0x0000000001E7BB70>
>>> s.age()
25
```
此外，注意到任意调用如s.abc都会返回None，这是因为我们定义的 `__getattr__` 默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误：
```
class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)
```
