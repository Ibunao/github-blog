---
title: Numpy 基础
date: 2019-04-11 11:56:02
tags:
    - numpy  
categories:   
    - 数据分析  
    - Numpy  
---


[Numpy 文档](https://www.numpy.org/)  
[Numpy 常用的运算方法](https://docs.scipy.org/doc/numpy/reference/routines.math.html)   


```python
import numpy as np
import random
```

## numpy 比原生的 python 计算更省资源、速度更快


```python
my_arr = np.arange(1000000)
my_list = list(range(1000000))
```


```python
%time for _ in range(10): my_arr2 = my_arr * 2
```

    Wall time: 20 ms



```python
%time for _ in range(10): my_list2 = [x * 2 for x in my_list]
```

    Wall time: 969 ms

<!-- more -->
## 创建数组 ndarray

### array、arange 方法创建数组


```python
# 创建数据类型为ndarray的数组
t1 = np.array([1, 2, 3])
print(t1, type(t1))

t2 = np.array(range(10))
print(t2)

# 和range用法一样，快速生成一个数组
t3 = np.arange(10)
print(t3)

```

    [1 2 3] <class 'numpy.ndarray'>
    [0 1 2 3 4 5 6 7 8 9]
    [0 1 2 3 4 5 6 7 8 9]



```python
# 获取数组的数据类型
t3.dtype
```




    dtype('int64')



### 数据类型


```python
# dtype 创建数组指定数据类型
t4 = np.array(range(10), dtype='float')
# 获取数据的数据类型
t4.dtype
```




    dtype('float64')




```python
# 更改数组的数据类型
t5 = t4.astype('int8')
t5
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=int8)




```python
t4.astype(np.int8)
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=int8)



数据类型列表  

| 类型 | 类型代码 | 说明 |
| :------------- | :------------- |:------------- |
| `int8\uint8` | `i1\u1`  | 有符号\无符号的 8 位（1 字节）整数 |
| `int16\uint16` | `i1\u1`  | 有符号\无符号的 16 位（2 字节）整数 |
| `int32\uint32` | `i1\u1`  | 有符号\无符号的 32 位（4 字节）整数 |
| `int64\uint64` | `i1\u1`  | 有符号\无符号的 64 位（8 字节）整数 |
| `float16` | `f2`  | 半精度浮点数 |
| `float32` | `f4或f`  | 标准单精度浮点数。与 C 的 float 兼容 |
| `float64` | `f8或d`  | 标准双精度浮点数。与 C 的 double 和 python 的 float 兼容 |
| `float128` | `f16或g`  | 扩展精度浮点数 |
| `complex64\complex128\complex256` | `c8\c16\c32`  | 分别用两个 32 位、64 位、128 为的浮点数表示复数 |
| `bool` | `?`  | 存储 True 和 False 值的布尔类型 |
| `object` | `O`  | Python 对象类型 |
| `string_` | `S`  | 固定长度的字符串类型(每个字符 1 个字节)。例如，要创建一个长度为 10 的字符串，使用 `S10` |
| `unicode_` | `U`  | 固定长度的 unicode 类型(字节数由平台决定)。跟字符串一样，如 `U10` |

### 创建多维数组


```python
t11 = np.array([[1, 2, 3], [4, 5, 6]])
t11
```




    array([[1, 2, 3],
           [4, 5, 6]])



#### 获取数组的形状 shape


```python
# 获取数组的形状
t11.shape
```




    (2, 3)



#### 改变数组的形状 reshape、flatten、ravel


```python
# reshape 改变数组的形状
t12 = np.arange(24).reshape(2, 3, 4)
t12
```




    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7],
            [ 8,  9, 10, 11]],
    
           [[12, 13, 14, 15],
            [16, 17, 18, 19],
            [20, 21, 22, 23]]])




```python
# flatten多维释放成一维
t13 = t12.flatten()
t13
```




    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
           17, 18, 19, 20, 21, 22, 23])




```python
# 拉伸成一维
t12.ravel()
```




    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
           17, 18, 19, 20, 21, 22, 23])



### 创建全是 0 的数组


```python
# 创建全是0的数组
t15 = np.zeros((3, 4))
t15
```




    array([[0., 0., 0., 0.],
           [0., 0., 0., 0.],
           [0., 0., 0., 0.]])




```python
np.zeros(10)
```




    array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])



### 创建全是 1 的数组


```python
# 创建全是1的数组
t16 = np.ones((3, 4))
t16
```




    array([[1., 1., 1., 1.],
           [1., 1., 1., 1.],
           [1., 1., 1., 1.]])




```python
np.ones(10)
```




    array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])



### 创建一个对角线为 1 的正方形数组(方阵)


```python
# 创建一个对角线为1的正方形数组(方阵)
t17 = np.eye(3)
t17
```




    array([[1., 0., 0.],
           [0., 1., 0.],
           [0., 0., 1.]])



### 创建空数组 empty

empty 只是分配了空间并未填充任何的值，下面看到的值可以理解成历史数据


```python
np.empty(5)
```




    array([2.15968811e-316, 0.00000000e+000, 2.37986283e-316, 2.39281447e-316,
           1.35807731e-312])




```python
np.empty((2, 3))
```




    array([[1.12409068, 0.71737825, 1.91333048],
           [0.95169061, 1.36121775, 1.16378946]])



### 创建填充指定值的数组


```python
np.full(5, fill_value=2)
```




    array([2, 2, 2, 2, 2])




```python
np.full((2, 3), fill_value=3)
```




    array([[3, 3, 3],
           [3, 3, 3]])



### 生成随机的数组


```python
data = np.random.randn(2, 3)
data
```




    array([[-1.12409068, -0.71737825, -1.91333048],
           [-0.95169061, -1.36121775,  1.16378946]])




```python
np.random.randn(10)
```




    array([-0.09859757, -1.94489982, -0.2328898 ,  1.21339405, -2.6686755 ,
            1.01910496,  0.39283428, -0.74445077,  0.16423021, -0.71799976])




```python
# 用normal来得到一个标准正态分布的4×4样本数组
samples = np.random.normal(size = (4, 4))
samples
```




    array([[ 1.38710548, -0.99141781, -0.01657807,  0.28104076],
           [-0.72489278,  0.14099596, -0.61639653,  1.31648008],
           [ 0.12896794, -0.31226401,  1.64074497,  0.18071008],
           [ 0.30653902,  1.42660833, -0.63305582,  3.74709392]])



随机方法列表  

| 函数 | 说明 |
| :------------- | :------------- |
| seed | 确定随机数生成器的种子，让每次随机数据一样 |
| permutation | 返回一个序列的随机排列或返回一个随机排列的范围 |
| shuffle | 对一个序列就地随机排列 |
| rand | 产生均匀分布的样本值 |
| randint | 从给定的上下限范围内随机选取整数 |
| randn | 产生正态分布（平均值为 0，标准差为 1）的样本值，类似于 MATLAB 接口 |
| binomial | 产生二项分布的样本值 |
| normal | 产生正态（高斯）分布的样本值 |
| beta | 产生 Beta 分布的样本值 |
| chisquare | 产生卡方分布的样本值 |
| gamma | 产生 Gamma 分布的样本值 |
| uniform | 产生在 [0, 1) 中均匀分布的样本值 |

## 转置（交换轴）

转置就是交换轴


```python
t = np.arange(24).reshape(4, 6)
t
```




    array([[ 0,  1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10, 11],
           [12, 13, 14, 15, 16, 17],
           [18, 19, 20, 21, 22, 23]])




```python
# 转置
t.T
```




    array([[ 0,  6, 12, 18],
           [ 1,  7, 13, 19],
           [ 2,  8, 14, 20],
           [ 3,  9, 15, 21],
           [ 4, 10, 16, 22],
           [ 5, 11, 17, 23]])




```python
# 转置方法
t.transpose()
```




    array([[ 0,  6, 12, 18],
           [ 1,  7, 13, 19],
           [ 2,  8, 14, 20],
           [ 3,  9, 15, 21],
           [ 4, 10, 16, 22],
           [ 5, 11, 17, 23]])




```python
# 转换高纬
# 创建三维数据
arr = np.arange(16).reshape(2,2,4)
print(arr, arr.shape)

# 转置
arr.transpose((1,0,2))
```

    [[[ 0  1  2  3]
      [ 4  5  6  7]]
    
     [[ 8  9 10 11]
      [12 13 14 15]]] (2, 2, 4)





    array([[[ 0,  1,  2,  3],
            [ 8,  9, 10, 11]],
    
           [[ 4,  5,  6,  7],
            [12, 13, 14, 15]]])




```python
# 交换轴
t.swapaxes(1, 0)
```




    array([[ 0,  6, 12, 18],
           [ 1,  7, 13, 19],
           [ 2,  8, 14, 20],
           [ 3,  9, 15, 21],
           [ 4, 10, 16, 22],
           [ 5, 11, 17, 23]])



## 索引与切片


```python
t31 = np.arange(24).reshape(4, 6)
t31
```




    array([[ 0,  1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10, 11],
           [12, 13, 14, 15, 16, 17],
           [18, 19, 20, 21, 22, 23]])



### 选取行


```python
# 获取第二行
t31[1]
```




    array([ 6,  7,  8,  9, 10, 11])




```python
# 取多行
# 取第二行到第四行
t31[1:4]
```




    array([[ 6,  7,  8,  9, 10, 11],
           [12, 13, 14, 15, 16, 17],
           [18, 19, 20, 21, 22, 23]])




```python
# 取不连续的多行
# 取第一行和第四行
t31[[1,3]]
```




    array([[ 6,  7,  8,  9, 10, 11],
           [18, 19, 20, 21, 22, 23]])



### 选取列


```python
# 获取第二列
t31[:,1]
```




    array([ 1,  7, 13, 19])




```python
# 取多列
# 取第二列到第四列
t31[:,1:4]
```




    array([[ 1,  2,  3],
           [ 7,  8,  9],
           [13, 14, 15],
           [19, 20, 21]])




```python
# 取不连续的多列
# 取第一列和第四列
t31[:, [1, 3]]
```




    array([[ 1,  3],
           [ 7,  9],
           [13, 15],
           [19, 21]])



### 选取点


```python
# 取指定的索引值
# 取第二行第二列的值
t31[1,1]
```




    7




```python
# 取(1, 1), (3, 3)点的值
t31[[1, 3], [1, 3]]
```




    array([ 7, 21])



## 修改数值

可以对索引获取到的值进行修改


```python
t31
```




    array([[ 0,  1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10, 11],
           [12, 13, 14, 15, 16, 17],
           [18, 19, 20, 21, 22, 23]])




```python
# 把第一列修改为 0
t31[:, 1] = 0
t31
```




    array([[ 0,  0,  2,  3,  4,  5],
           [ 6,  0,  8,  9, 10, 11],
           [12,  0, 14, 15, 16, 17],
           [18,  0, 20, 21, 22, 23]])



## 布尔索引


```python
t31
```




    array([[ 3,  3,  3,  3,  4,  5],
           [ 6,  7,  8,  9, 10, 11],
           [12, 13, 14, 15, 16, 17],
           [18, 19, 20, 21, 22, 23]])




```python
# 获取判读小于 3 的数组
t31 < 3
```




    array([[False, False, False, False, False, False],
           [False, False, False, False, False, False],
           [False, False, False, False, False, False],
           [False, False, False, False, False, False]])




```python
# 根据布尔数组，获取为 True 的数据
# 给小于3的赋值为3
t31[t31 < 3] = 3
t31
```




    array([[ 3,  3,  3,  3,  4,  5],
           [ 6,  7,  8,  9, 10, 11],
           [12, 13, 14, 15, 16, 17],
           [18, 19, 20, 21, 22, 23]])



## 三元运算 where


```python
t32 = np.arange(24).reshape(4, 6)
t32
```




    array([[ 0,  1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10, 11],
           [12, 13, 14, 15, 16, 17],
           [18, 19, 20, 21, 22, 23]])




```python
# 把小于等于 10 的替换成 0 ，大于 10 的替换成 20
np.where(t32 > 10, 20, 0)
```




    array([[ 0,  0,  0,  0,  0,  0],
           [ 0,  0,  0,  0,  0, 20],
           [20, 20, 20, 20, 20, 20],
           [20, 20, 20, 20, 20, 20]])



## 裁剪 clip

把小于某值的改成某值、把大于某值的改成某值


```python
t33 = np.arange(24).reshape(4, 6)
t33
```




    array([[ 0,  1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10, 11],
           [12, 13, 14, 15, 16, 17],
           [18, 19, 20, 21, 22, 23]])




```python
# 把小于10的替换成10， 大于18的替换成18
t33.clip(10, 18)
```




    array([[10, 10, 10, 10, 10, 10],
           [10, 10, 10, 10, 10, 11],
           [12, 13, 14, 15, 16, 17],
           [18, 18, 18, 18, 18, 18]])




```python
# 由于 np.nan 是一个浮点型，所以要把数组改变成浮点型才能赋值成功
t34 = np.arange(24).reshape(4, 6).astype('float')
t34[t34 > 20] = np.nan
t34
```




    array([[ 0.,  1.,  2.,  3.,  4.,  5.],
           [ 6.,  7.,  8.,  9., 10., 11.],
           [12., 13., 14., 15., 16., 17.],
           [18., 19., 20., nan, nan, nan]])




```python
# 把小于 10 的替换成 10 ，大于 18 的替换成 18 ，nan 并没有改变，非数值类型无法计算和判断
t34.clip(10, 18)
```




    array([[10., 10., 10., 10., 10., 10.],
           [10., 10., 10., 10., 10., 11.],
           [12., 13., 14., 15., 16., 17.],
           [18., 18., 18., nan, nan, nan]])



## 非数值 nan 和无穷 inf

nan 表示非数值类型，inf 表示正无穷，-inf 表示负无穷；这俩都是 float 类型的  


```python
type(np.nan)
```




    float




```python
type(np.inf)
```




    float



nan和任何数值计算都是nan，nan不等于nan，判断是否是nan可以用 `isnan()`  


```python
np.nan != np.nan
```




    True




```python
t35 = np.array([1., 3. , np.nan])
t35
```




    array([ 1.,  3., nan])




```python
# 根据 nan != nan 的特性来获取是 nan 的布尔数组
t35 != t35
```




    array([False, False,  True])




```python
# 计算 nan 个数
# count_nonzero 计算非 0 的个数
np.count_nonzero(t35 != t35)
```




    1




```python
# 获取是否是 nan 的布尔数组
np.isnan(t35)
```




    array([False, False,  True])




```python
# 把 nan 替换成 0
t35[np.isnan(t35)] = 0
t35
```




    array([1., 3., 0.])



## 数学运算

numpy 的计算有个广播效应，会逐个元素、逐行、逐列进行计算


```python
x = np.array([[1,2],[3,4]], dtype=np.float64)
x
```




    array([[1., 2.],
           [3., 4.]])




```python
y = np.array([[5,6],[7,8]], dtype=np.float64)
y
```




    array([[5., 6.],
           [7., 8.]])




```python
z = np.array([2, 3])
z
```




    array([2, 3])



### 逐元素求和


```python
x + 10
```




    array([[11., 12.],
           [13., 14.]])




```python
x + y
```




    array([[ 6.,  8.],
           [10., 12.]])




```python
np.add(x,y)
```




    array([[ 6.,  8.],
           [10., 12.]])




```python
x + z
```




    array([[3., 5.],
           [5., 7.]])



### 逐元素作差


```python
x - 10
```




    array([[-9., -8.],
           [-7., -6.]])




```python
x - y
```




    array([[-4., -4.],
           [-4., -4.]])




```python
np.subtract(x,y)
```




    array([[-4., -4.],
           [-4., -4.]])




```python
x - z
```




    array([[-1., -1.],
           [ 1.,  1.]])



### 逐元素相乘


```python
x * 10
```




    array([[10., 20.],
           [30., 40.]])




```python
x * y
```




    array([[ 5., 12.],
           [21., 32.]])




```python
np.multiply(x,y)
```




    array([[ 5., 12.],
           [21., 32.]])




```python
x * z
```




    array([[ 2.,  6.],
           [ 6., 12.]])



### 逐元素相除


```python
x / 10
```




    array([[0.1, 0.2],
           [0.3, 0.4]])




```python
np.divide(x, y)
```




    array([[0.2       , 0.33333333],
           [0.42857143, 0.5       ]])



### 逐元素求平方根


```python
# 求平方根
np.sqrt(x)
```




    array([[1.        , 1.41421356],
           [1.73205081, 2.        ]])



看图理解广播效应  
![](http://www.astroml.org/_images/fig_broadcast_visual_1.png)

## 统计函数


```python
t41 = np.arange(24).reshape(4, 6)
t41
```




    array([[ 0,  1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10, 11],
           [12, 13, 14, 15, 16, 17],
           [18, 19, 20, 21, 22, 23]])



### 求和


```python
# 求所有的和
np.sum(t41)
```




    276




```python
t41.sum()
```




    276




```python
# 求某一轴上的和
# 求0轴(x轴)上的和  竖着求和
t41.sum(axis = 0)
```




    array([36, 40, 44, 48, 52, 56])




```python
np.sum(t41, axis = 0)
```




    array([36, 40, 44, 48, 52, 56])



### 累加 cumsum


```python
draws = np.random.randint(0, 2, size=10)
draws
```




    array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0])




```python
steps = np.where(draws > 0, 1, -1)
steps
```




    array([-1, -1,  1, -1, -1,  1, -1, -1,  1, -1])




```python
steps.cumsum()
```




    array([-1, -2, -1, -2, -3, -2, -3, -4, -3, -4], dtype=int32)



### 求均值


```python
# 求所有的均值
np.mean(t41)
```




    11.5




```python
t41.mean()
```




    11.5




```python
# 求某一轴上的均值
# 求0轴(x轴)上的均值  竖着求均值
t41.mean(axis = 0)
```




    array([ 9., 10., 11., 12., 13., 14.])




```python
np.mean(t41, axis = 0)
```




    array([ 9., 10., 11., 12., 13., 14.])



### 求中值


```python
# 求所有的中值
np.median(t41)
```




    11.5




```python
# 求0轴(x轴)上的中值  竖着求中值
np.median(t41, axis = 0)
```




    array([ 9., 10., 11., 12., 13., 14.])



### 求最大值、最小值


```python
# 求所有的最大值
np.max(t41)
```




    23




```python
t41.max()
```




    23




```python
# 求某一轴上的最大值
# 求0轴(x轴)上的最大值 竖着求
np.max(t41, axis = 0)
```




    array([18, 19, 20, 21, 22, 23])




```python
t41.max(axis = 0)
```




    array([18, 19, 20, 21, 22, 23])




```python
# 求所有的最小值
np.min(t41)
```




    0




```python
t41.min()
```




    0




```python
# 求某一轴上的最小值
# 求0轴(x轴)上的最小值 竖着求
np.min(t41, axis = 0)
```




    array([0, 1, 2, 3, 4, 5])




```python
t41.min(axis = 0)
```




    array([0, 1, 2, 3, 4, 5])



### 求极值

最大值 减去 最小值


```python
# 求所有数据的极值
np.ptp(t41)
```




    23




```python
t41.ptp()
```




    23




```python
# 求某一轴上的极值
# 求0轴(x轴)上的极值
np.ptp(t41, axis = 0)
```




    array([18, 18, 18, 18, 18, 18])




```python
t41.ptp(axis = 0)
```




    array([18, 18, 18, 18, 18, 18])



### 求标准差


```python
# 求所有数据的标准差
np.std(t41)
```




    6.922186552431729




```python
t41.std()
```




    6.922186552431729




```python
# 求某一轴上的标准差
# 求0轴(x轴)上的标准差
np.std(t41, axis = 0)
```




    array([6.70820393, 6.70820393, 6.70820393, 6.70820393, 6.70820393,
           6.70820393])




```python
t41.std(axis = 0)
```




    array([6.70820393, 6.70820393, 6.70820393, 6.70820393, 6.70820393,
           6.70820393])



### 缺失值填充均值


```python
t42 = np.arange(24).reshape(4, 6).astype('float')
t42
```




    array([[ 0.,  1.,  2.,  3.,  4.,  5.],
           [ 6.,  7.,  8.,  9., 10., 11.],
           [12., 13., 14., 15., 16., 17.],
           [18., 19., 20., 21., 22., 23.]])




```python
t42[[1,3], [1, 3]] = np.nan
t42
```




    array([[ 0.,  1.,  2.,  3.,  4.,  5.],
           [ 6., nan,  8.,  9., 10., 11.],
           [12., 13., 14., 15., 16., 17.],
           [18., 19., 20., nan, 22., 23.]])




```python
# 获取到nan
t42[:, 1][t42[:, 1] != t42[:, 1]]
```




    array([nan])




```python
# 获取到nan的数量
np.count_nonzero(t42[:, 1][t42[:, 1] != t42[:, 1]])
```




    1




```python
def fill_nan_by_column_mean(t):
    for i in range(t.shape[1]):
        nan_num = np.count_nonzero(t[:, i][t[:, i] != t[:, i]])
        # 如果存在nan
        if nan_num > 0:
            now_col = t[:, i]
            # 计算非nan的和
            now_col_not_nan = now_col[np.isnan(now_col) == False].sum()
            # 计算平均数
            now_col_mean = now_col_not_nan / (t.shape[0] - nan_num)
            # 给nan赋值平均数
            now_col[np.isnan(now_col)] = now_col_mean
            # 更新列
            t[:, i] = now_col
```


```python
fill_nan_by_column_mean(t42)
t42
```




    array([[ 0.,  1.,  2.,  3.,  4.,  5.],
           [ 6., 11.,  8.,  9., 10., 11.],
           [12., 13., 14., 15., 16., 17.],
           [18., 19., 20.,  9., 22., 23.]])



## 数组的拼接 concatenate、vstack、hstack


```python
import numpy as np
t51 = np.arange(12).reshape(2, 6)
t51
```




    array([[ 0,  1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10, 11]])




```python
t52 = np.arange(12, 24).reshape(2, 6)
t52
```




    array([[12, 13, 14, 15, 16, 17],
           [18, 19, 20, 21, 22, 23]])



### 竖直、横向拼接 concatenate


```python
# 竖直拼接
np.concatenate([t51, t52], axis=0)
```




    array([[ 0,  1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10, 11],
           [12, 13, 14, 15, 16, 17],
           [18, 19, 20, 21, 22, 23]])




```python
# 横向拼接
np.concatenate([t51, t52], axis=1)
```




    array([[ 0,  1,  2,  3,  4,  5, 12, 13, 14, 15, 16, 17],
           [ 6,  7,  8,  9, 10, 11, 18, 19, 20, 21, 22, 23]])



### 竖直拼接 vstack


```python
# 竖直拼接  
np.vstack((t51, t52))
```




    array([[ 0,  1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10, 11],
           [12, 13, 14, 15, 16, 17],
           [18, 19, 20, 21, 22, 23]])



### 横向拼接 hstack


```python
# 水平拼接
np.hstack((t51, t52))
```




    array([[ 0,  1,  2,  3,  4,  5, 12, 13, 14, 15, 16, 17],
           [ 6,  7,  8,  9, 10, 11, 18, 19, 20, 21, 22, 23]])



## 数组的拆分 split


```python
arr = np.random.rand(5,5)
arr
```




    array([[0.51323562, 0.58188986, 0.96645492, 0.74560963, 0.25843771],
           [0.66209902, 0.16546576, 0.35851699, 0.81376061, 0.18680752],
           [0.42327984, 0.33418805, 0.61434484, 0.02092018, 0.7348934 ],
           [0.6246003 , 0.4429335 , 0.99242307, 0.53883774, 0.93484283],
           [0.45927832, 0.13045444, 0.90311103, 0.14345885, 0.62611419]])




```python
# 横向拆分
first, second, third = np.split(arr, [1,3], axis=0)
print(first, '\n\n', second, '\n\n', third)
```

    [[0.51323562 0.58188986 0.96645492 0.74560963 0.25843771]] 
    
     [[0.66209902 0.16546576 0.35851699 0.81376061 0.18680752]
     [0.42327984 0.33418805 0.61434484 0.02092018 0.7348934 ]] 
    
     [[0.6246003  0.4429335  0.99242307 0.53883774 0.93484283]
     [0.45927832 0.13045444 0.90311103 0.14345885 0.62611419]]



```python
# 竖直拆分
first, second, third = np.split(arr, [1,3], axis=1)
print(first, '\n\n', second, '\n\n', third)
```

    [[0.51323562]
     [0.66209902]
     [0.42327984]
     [0.6246003 ]
     [0.45927832]] 
    
     [[0.58188986 0.96645492]
     [0.16546576 0.35851699]
     [0.33418805 0.61434484]
     [0.4429335  0.99242307]
     [0.13045444 0.90311103]] 
    
     [[0.74560963 0.25843771]
     [0.81376061 0.18680752]
     [0.02092018 0.7348934 ]
     [0.53883774 0.93484283]
     [0.14345885 0.62611419]]


## 行或列交换位置

利用 索引 进行 行与行、列与列的交换


```python
t61 = np.arange(24).reshape(4, 6)
t61
```




    array([[ 0,  1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10, 11],
           [12, 13, 14, 15, 16, 17],
           [18, 19, 20, 21, 22, 23]])



### 行交换


```python
# 行交换
# 第二行和第三行交换
t61[[2, 1], :] = t61[[1, 2], :]
t61
```




    array([[ 0,  1,  2,  3,  4,  5],
           [12, 13, 14, 15, 16, 17],
           [ 6,  7,  8,  9, 10, 11],
           [18, 19, 20, 21, 22, 23]])



### 列交换


```python
# 列交换
# 第二列和第三列交换
t61[:, [1, 2]] = t61[:, [2, 1]]
t61
```




    array([[ 0,  2,  1,  3,  4,  5],
           [12, 14, 13, 15, 16, 17],
           [ 6,  8,  7,  9, 10, 11],
           [18, 20, 19, 21, 22, 23]])



## 线性代数

线性代数忘了，复习之后再补充


```python
x = np.array([[1., 2., 3.], [4., 5., 6.]])
x
```




    array([[1., 2., 3.],
           [4., 5., 6.]])




```python
y = np.array([[6., 23.], [-1, 7], [8, 9]])
y
```




    array([[ 6., 23.],
           [-1.,  7.],
           [ 8.,  9.]])




```python
x.dot(y)
```




    array([[ 28.,  64.],
           [ 67., 181.]])



常用的线性代数方法  

| 函数 | 说明 |
| :------------- | :------------- |
| diag | 以一维数组的形式返回方阵的对角线（或非对角线）元素，或将一组数组转换为方阵（非对角线元素为 0) |
| dot | 矩阵乘法 |
| trace | 计算对角线元素的和 |
| det | 计算矩阵行列式 |
| eig | 计算方阵的本征值和本征向量 |
| inv | 计算方阵的逆 |
| pinv | 计算方阵的 Moore-Penrose 伪逆 |
| qr | 计算 QR 分解 |
| svd | 计算奇异值分解（SVD） |
| solve | 解线性方程组 Ax = b，其中 A 为一个方阵 |
| lstsq | 计算 Ax = b 的最小值 |

## Numpy 的文件输入输出


```python
# 读取 csv 数据
# 读取文件数据，以 , 分割
arr = np.loadtxt('data/array_ex.txt', delimiter=',')
arr
```




    array([[1., 2., 3., 4.],
           [5., 6., 7., 8.],
           [2., 3., 4., 5.]])




```python
# 写入数据
arr = np.arange(50).reshape(2,5,5)
print(arr)
# 保存到文件 执行之后我们可以看到一个 some_array.npy 文件
np.save('data/some_array', arr)
```

    [[[ 0  1  2  3  4]
      [ 5  6  7  8  9]
      [10 11 12 13 14]
      [15 16 17 18 19]
      [20 21 22 23 24]]
    
     [[25 26 27 28 29]
      [30 31 32 33 34]
      [35 36 37 38 39]
      [40 41 42 43 44]
      [45 46 47 48 49]]]



```python
# 加载 numpy 存入的数据
np.load('data/some_array.npy')
```




    array([[[ 0,  1,  2,  3,  4],
            [ 5,  6,  7,  8,  9],
            [10, 11, 12, 13, 14],
            [15, 16, 17, 18, 19],
            [20, 21, 22, 23, 24]],
    
           [[25, 26, 27, 28, 29],
            [30, 31, 32, 33, 34],
            [35, 36, 37, 38, 39],
            [40, 41, 42, 43, 44],
            [45, 46, 47, 48, 49]]])




```python
# 多个数组同时 压缩存储
np.savez('data/some_arrayz', a=arr, b=arr, c=arr)
```


```python
# 读取多个数组压缩后的文件数据  
arch = np.load('data/some_arrayz.npz')
arch['a']
```




    array([[[ 0,  1,  2,  3,  4],
            [ 5,  6,  7,  8,  9],
            [10, 11, 12, 13, 14],
            [15, 16, 17, 18, 19],
            [20, 21, 22, 23, 24]],
    
           [[25, 26, 27, 28, 29],
            [30, 31, 32, 33, 34],
            [35, 36, 37, 38, 39],
            [40, 41, 42, 43, 44],
            [45, 46, 47, 48, 49]]])



## 补充方法

### 获取最大值或最小值的位置


```python
t71 = np.arange(24).reshape(4, 6)
t71
```




    array([[ 0,  1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10, 11],
           [12, 13, 14, 15, 16, 17],
           [18, 19, 20, 21, 22, 23]])




```python
# 获取竖着的最大的坐标值
np.argmax(t71, axis = 0)
```




    array([3, 3, 3, 3, 3, 3])




```python
# 获取横着的最大的坐标值
np.argmax(t71, axis = 1)
```




    array([5, 5, 5, 5])




```python
# 获取竖着的最小的坐标值
np.argmin(t71, axis = 0)
```




    array([0, 0, 0, 0, 0, 0])



### 小数四舍五入


```python
# 生成随机数
t6 = np.array([random.random() for i in range(6)])
t6
```




    array([0.98162522, 0.34459695, 0.22603344, 0.14799318, 0.34621457,
           0.78629889])




```python
# 保留小数位数, 指定小数位数（四舍五入）
t7 = np.round(t6, 2)
t7
```




    array([0.98, 0.34, 0.23, 0.15, 0.35, 0.79])



### 排序


```python
arr = np.random.randn(6)
arr
```




    array([ 0.76489147,  0.65253326, -1.18840851,  1.072042  ,  0.84549233,
           -0.45669231])




```python
# 从小到大排序
arr.sort()
arr
```




    array([-1.18840851, -0.45669231,  0.65253326,  0.76489147,  0.84549233,
            1.072042  ])




```python
# 多维数组指定根据某一维进行排序
arr = np.random.randn(5,3) * 10
print(arr)
# 根据第一维进行排序
arr.sort(1)
print(arr)
```

    [[ -7.17969463  -1.44401898  -3.04804793]
     [ -8.68580105   1.55168534 -10.53525551]
     [ -7.26578011 -12.26002953  -8.4707146 ]
     [ 10.16939017 -14.70839867   5.48670214]
     [ -8.65931279 -12.05255559  -5.20118478]]
    [[ -7.17969463  -3.04804793  -1.44401898]
     [-10.53525551  -8.68580105   1.55168534]
     [-12.26002953  -8.4707146   -7.26578011]
     [-14.70839867   5.48670214  10.16939017]
     [-12.05255559  -8.65931279  -5.20118478]]



```python

```

### 唯一化


```python
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
np.unique(names)
```




    array(['Bob', 'Joe', 'Will'], dtype='<U4')




```python
names = np.array([['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], ['ding', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe']])
np.unique(names)
```




    array(['Bob', 'Joe', 'Will', 'ding'], dtype='<U4')


